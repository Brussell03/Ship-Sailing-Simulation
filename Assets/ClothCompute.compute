// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateVelocity
#pragma kernel PredictPosition
#pragma kernel SolveStretchingBatch1
#pragma kernel SolveStretchingBatch2
#pragma kernel SolveStretchingBatch3
#pragma kernel SolveStretchingBatch4
#pragma kernel SolveStretchingBatch5
#pragma kernel SolveStretchingBatch6
#pragma kernel SolveBendingBatch1
#pragma kernel SolveBendingBatch2
#pragma kernel SolveBendingBatch3
#pragma kernel SolveBendingBatch4
#pragma kernel SolveBendingBatch5
#pragma kernel SolveBendingBatch6

RWStructuredBuffer<float3> x;
RWStructuredBuffer<float3> v;
RWStructuredBuffer<float3> p;
StructuredBuffer<float> w;
StructuredBuffer<int> stretchingIDs;
StructuredBuffer<int> bendingIDs;
StructuredBuffer<float> d0;
StructuredBuffer<float> dihedral0;
StructuredBuffer<float3> stepVelocity;
StructuredBuffer<float3> gravityVector;
StructuredBuffer<float3> windVector;
StructuredBuffer<int> startIndex;
uint numSubsteps;
uint numVertices;
uint numCloths;
float dt_step;
float damping;
float maxVelocity;
float stretchingAlpha;
float bendingAlpha;
uint projectionIterations;

int GetClothIndex(uint3 id)
{
    int clothIndex = 0;
    if (numCloths > 1)
    {
        for (int j = 1; j < numCloths; j++)
        {
            if (id.x >= startIndex[j])
            {
                clothIndex = j;
            }
            else
            {
                break;
            }
        }
    }
    
    return clothIndex;
}

[numthreads(128, 1, 1)]
void UpdateVelocity (uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    int clothIndex = GetClothIndex(id);
    
    v[id.x] = (p[id.x] - x[id.x] + (w[id.x] == 0 ? 0.0f : 1.0f) * stepVelocity[clothIndex]) / dt_step;
    v[id.x] *= (1 - damping / numSubsteps); // Damp Velocities
    x[id.x] = p[id.x];
}

[numthreads(128, 1, 1)]
void PredictPosition (uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    int clothIndex = GetClothIndex(id);
    
    v[id.x] += dt_step * w[id.x] * (gravityVector[clothIndex] + windVector[clothIndex]); // Applies gravity and wind

    float sqrMagnitude = dot(v[id.x], v[id.x]);
    if (sqrMagnitude > maxVelocity * maxVelocity)
    {
        v[id.x] = ((sqrMagnitude > 0.0f) ? (v[id.x] / sqrt(sqrMagnitude)) : float3(0.0f, 0.0f, 0.0f)) * maxVelocity;
        //v[id.x] = v[id.x] * maxVelocity;
    }

    p[id.x] = x[id.x] + dt_step * v[id.x] - (w[id.x] == 0 ? 0.0f : 1.0f) * stepVelocity[clothIndex];
}

[numthreads(128, 1, 1)]
void SolveStretchingBatch1(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - d0[id.x];
        float s = -C / (wT + stretchingAlpha);

        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id0] = p0;
    p[id1] = p1;
}

[numthreads(128, 1, 1)]
void SolveStretchingBatch2(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - d0[id.x];
        float s = -C / (wT + stretchingAlpha);

        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id0] = p0;
    p[id1] = p1;
}

[numthreads(128, 1, 1)]
void SolveStretchingBatch3(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - d0[id.x];
        float s = -C / (wT + stretchingAlpha);

        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id0] = p0;
    p[id1] = p1;
}

[numthreads(128, 1, 1)]
void SolveStretchingBatch4(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - d0[id.x];
        float s = -C / (wT + stretchingAlpha);

        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id0] = p0;
    p[id1] = p1;
}

[numthreads(128, 1, 1)]
void SolveStretchingBatch5(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - d0[id.x];
        float s = -C / (wT + stretchingAlpha);

        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id0] = p0;
    p[id1] = p1;
}

[numthreads(128, 1, 1)]
void SolveStretchingBatch6(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - d0[id.x];
        float s = -C / (wT + stretchingAlpha);

        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id0] = p0;
    p[id1] = p1;
}

[numthreads(128, 1, 1)]
void SolveBendingBatch1(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - dihedral0[id.x];
        float s = -C / (wT + bendingAlpha);
    
        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id2] = p0;
    p[id3] = p1;
}

[numthreads(128, 1, 1)]
void SolveBendingBatch2(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - dihedral0[id.x];
        float s = -C / (wT + bendingAlpha);
    
        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id2] = p0;
    p[id3] = p1;
}

[numthreads(128, 1, 1)]
void SolveBendingBatch3(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - dihedral0[id.x];
        float s = -C / (wT + bendingAlpha);
    
        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id2] = p0;
    p[id3] = p1;
}

[numthreads(128, 1, 1)]
void SolveBendingBatch4(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - dihedral0[id.x];
        float s = -C / (wT + bendingAlpha);
    
        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id2] = p0;
    p[id3] = p1;
}

[numthreads(128, 1, 1)]
void SolveBendingBatch5(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - dihedral0[id.x];
        float s = -C / (wT + bendingAlpha);
    
        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id2] = p0;
    p[id3] = p1;
}

[numthreads(128, 1, 1)]
void SolveBendingBatch6(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        return;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    for (int i = 0; i < projectionIterations; i++)
    {
        float sqrMagnitude = dot(p0 - p1, p0 - p1);
        float len = sqrt(sqrMagnitude);
        if (len == 0)
            return;

        float C = len - dihedral0[id.x];
        float s = -C / (wT + bendingAlpha);
    
        float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
        p0 += p0p1_norm * s * w0;
        p1 += p0p1_norm * -s * w1;
    }
    
    p[id2] = p0;
    p[id3] = p1;
}