// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateVelocity
#pragma kernel PredictPosition
#pragma kernel SolveStretching
#pragma kernel SolveBending

float3 gravityVector;
StructuredBuffer<float3> x;
StructuredBuffer<float3> v;
StructuredBuffer<float3> p;
StructuredBuffer<float> w;
StructuredBuffer<float> stretchingIDs;
StructuredBuffer<float> bendingIDs;
StructuredBuffer<float> d0;
StructuredBuffer<float> dihedral0;
uint numSubsteps;
uint numVertices;
float3 stepVelocity;
float dt_step;
float damping;
float maxVelocity;
float stretchingAlpha;
float bendingAlpha;

[numthreads(16,1,1)]
void UpdateVelocity (uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    v[id.x] = (p[id.x] - x[id.x] + w[id.x] * stepVelocity) / dt_step;
    v[id.x] *= (1 - damping / numSubsteps); // Damp Velocities
    x[id.x] = p[id.x];
}

[numthreads(16, 1, 1)]
void PredictPosition (uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    v[id.x] += dt_step * w[id.x] * gravityVector; // Applies gravity

    float sqrMagnitude = dot(v[id.x], v[id.x]);
    if (sqrMagnitude > maxVelocity * maxVelocity)
    {
        v[id.x] = ((sqrMagnitude > 0.0f) ? (v[id.x] / sqrt(sqrMagnitude)) : float3(0.0f, 0.0f, 0.0f)) * maxVelocity;
        //v[id.x] = v[id.x] * maxVelocity;
    }

    p[id.x] = x[id.x] + dt_step * v[id.x] - w[id.x] * stepVelocity;
}

[numthreads(16, 1, 1)]
void SolveStretching(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id0 = stretchingIDs[id.x * 2];
    int id1 = stretchingIDs[id.x * 2 + 1];
    float w0 = w[id0];
    float w1 = w[id1];
    float wT = w0 + w1;
    if (wT == 0)
        continue;

    float3 p0 = p[id0];
    float3 p1 = p[id1];
    
    float sqrMagnitude = dot(p0 - p1, p0 - p1);
    float len = sqrt(sqrMagnitude);
    if (len == 0)
        continue;

    float C = len - d0[id.x];
    float s = -C / (wT + stretchingAlpha);

    float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
    p[id0] += p0p1_norm * s * w0;
    p[id1] += p0p1_norm * -s * w1;
}

[numthreads(16, 1, 1)]
void SolveBending(uint3 id : SV_DispatchThreadID)
{
    //if (id.x >= numVertices)
    //    return;
    
    int id2 = bendingIDs[id.x * 4 + 2];
    int id3 = bendingIDs[id.x * 4 + 3];

    float w0 = w[id2];
    float w1 = w[id3];
    float wT = w0 + w1;
    if (wT == 0)
        continue;

    float3 p0 = p[id2];
    float3 p1 = p[id3];
    
    float sqrMagnitude = dot(p0 - p1, p0 - p1);
    float len = sqrt(sqrMagnitude);
    if (len == 0)
        continue;

    float C = len - dihedral0[id.x];
    float s = -C / (wT + bendingAlpha);
    
    float3 p0p1_norm = (sqrMagnitude > 0.0f) ? ((p0 - p1) / len) : float3(0.0f, 0.0f, 0.0f);
    p[id2] += p0p1_norm * s * w0;
    p[id3] += p0p1_norm * -s * w1;
}